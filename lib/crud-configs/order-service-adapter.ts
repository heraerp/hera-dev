/**
 * üè≠ MANUFACTURED: Orders Service Adapter
 * Generated by HERA Toyota Manufacturing System
 * Compatible with HERA Universal Data Schema
 */

import { CRUDServiceInterface } from '@/templates/crud/types/crud-types'
import { UniversalTransactionService } from '@/lib/services/universalTransactionService'

// üéØ Order Entity Interface (Universal Schema Compliant)
export interface OrderEntity {
  id: string
  organizationId: string
  
  // Universal Transaction Fields
  transaction_number: string
  transaction_type: 'SALES_ORDER'
  transaction_date: string
  transaction_status: 'PENDING' | 'CONFIRMED' | 'PREPARING' | 'READY' | 'COMPLETED' | 'CANCELLED'
  total_amount: number
  currency: string
  
  // Order-Specific Fields (stored in metadata)
  customer_name: string
  customer_phone?: string
  order_type: 'dine_in' | 'takeout' | 'delivery' | 'online'
  table_number?: string
  
  // Financial Details
  subtotal?: number
  tax_amount?: number
  tip_amount?: number
  payment_method?: 'cash' | 'card' | 'mobile' | 'gift_card'
  payment_status?: 'pending' | 'paid' | 'refunded' | 'partial'
  
  // Timing
  estimated_completion?: string
  actual_completion?: string
  
  // Instructions and Notes
  special_instructions?: string
  delivery_address?: string
  delivery_fee?: number
  assigned_staff?: string
  internal_notes?: string
  
  // System Fields
  created_at: string
  updated_at: string
  
  // Order Items (from universal_transaction_lines)
  items?: OrderLineItem[]
}

export interface OrderLineItem {
  id: string
  transaction_id: string
  entity_id: string
  line_description: string
  quantity: number
  unit_price: number
  line_amount: number
  line_order: number
}

// üéØ Order Statistics Interface
export interface OrderStatistics {
  total_orders: number
  pending_orders: number
  active_orders: number
  completed_orders: number
  cancelled_orders: number
  total_revenue: number
  average_order_value: number
  peak_hours: string
}

// üè≠ Orders Service Adapter (Toyota Manufacturing Pattern)
export const createOrderServiceAdapter = (): CRUDServiceInterface => {
  return {
    async list(organizationId: string, options: any = {}) {
      console.log('üîç OrderServiceAdapter.list called with:', { organizationId, options })
      
      try {
        // Convert CRUD options to UniversalTransactionService format
        const serviceOptions = {
          page: options.page || 1,
          pageSize: options.pageSize || 25,
          search: options.search || '',
          filters: {
            transaction_status: options.filters?.transaction_status,
            order_type: options.filters?.order_type,
            payment_status: options.filters?.payment_status,
            date_range: options.filters?.date_range,
            amount_range: options.filters?.amount_range,
            table_number: options.filters?.table_number
          },
          sort: options.sort || { key: 'transaction_date', direction: 'desc' }
        }
        
        // Use UniversalTransactionService for orders
        const result = await UniversalTransactionService.listOrders(organizationId, serviceOptions)
        
        if (!result.success) {
          throw new Error(result.error || 'Failed to fetch orders')
        }
        
        // Transform to CRUD format
        const orders = result.orders?.map(transformOrderToCRUD) || []
        
        console.log('‚úÖ OrderServiceAdapter.list success:', {
          count: orders.length,
          total: result.metadata?.total || 0
        })
        
        return {
          success: true,
          data: orders,
          metadata: {
            total: result.metadata?.total || 0,
            page: result.metadata?.page || 1,
            pageSize: result.metadata?.pageSize || 25,
            hasMore: result.metadata?.hasMore || false
          }
        }
      } catch (error) {
        console.error('‚ùå OrderServiceAdapter.list error:', error)
        return {
          success: false,
          error: error instanceof Error ? error.message : 'Failed to fetch orders'
        }
      }
    },

    async create(organizationId: string, data: any) {
      console.log('üîç OrderServiceAdapter.create called with:', { organizationId, data })
      
      try {
        // Transform CRUD data to UniversalTransactionService format
        const orderData = {
          organizationId,
          customerName: data.customer_name,
          customerPhone: data.customer_phone,
          orderType: data.order_type,
          tableNumber: data.table_number,
          totalAmount: data.total_amount,
          subtotal: data.subtotal,
          taxAmount: data.tax_amount,
          tipAmount: data.tip_amount || 0,
          paymentMethod: data.payment_method,
          paymentStatus: data.payment_status || 'pending',
          estimatedCompletion: data.estimated_completion,
          specialInstructions: data.special_instructions,
          deliveryAddress: data.delivery_address,
          deliveryFee: data.delivery_fee || 0,
          assignedStaff: data.assigned_staff,
          internalNotes: data.internal_notes,
          items: data.items || []
        }
        
        const result = await UniversalTransactionService.createOrder(orderData)
        
        if (!result.success) {
          throw new Error(result.error || 'Failed to create order')
        }
        
        console.log('‚úÖ OrderServiceAdapter.create success:', result.order?.id)
        
        return {
          success: true,
          data: transformOrderToCRUD(result.order)
        }
      } catch (error) {
        console.error('‚ùå OrderServiceAdapter.create error:', error)
        return {
          success: false,
          error: error instanceof Error ? error.message : 'Failed to create order'
        }
      }
    },

    async update(organizationId: string, id: string, data: any) {
      console.log('üîç OrderServiceAdapter.update called with:', { organizationId, id, data })
      
      try {
        // Handle status updates specially
        if (data.transaction_status && data.transaction_status !== data.previous_status) {
          const statusResult = await UniversalTransactionService.updateOrderStatus(
            id, 
            data.transaction_status
          )
          
          if (!statusResult.success) {
            throw new Error(statusResult.error || 'Failed to update order status')
          }
        }
        
        // Handle other updates
        const updateData = {
          customerName: data.customer_name,
          customerPhone: data.customer_phone,
          orderType: data.order_type,
          tableNumber: data.table_number,
          totalAmount: data.total_amount,
          subtotal: data.subtotal,
          taxAmount: data.tax_amount,
          tipAmount: data.tip_amount,
          paymentMethod: data.payment_method,
          paymentStatus: data.payment_status,
          estimatedCompletion: data.estimated_completion,
          actualCompletion: data.actual_completion,
          specialInstructions: data.special_instructions,
          deliveryAddress: data.delivery_address,
          deliveryFee: data.delivery_fee,
          assignedStaff: data.assigned_staff,
          internalNotes: data.internal_notes
        }
        
        // Remove undefined fields
        const cleanData = Object.fromEntries(
          Object.entries(updateData).filter(([_, value]) => value !== undefined)
        )
        
        if (Object.keys(cleanData).length > 0) {
          const result = await UniversalTransactionService.updateOrder(id, cleanData)
          
          if (!result.success) {
            throw new Error(result.error || 'Failed to update order')
          }
        }
        
        // Fetch updated order
        const updatedOrder = await UniversalTransactionService.getOrder(id)
        
        console.log('‚úÖ OrderServiceAdapter.update success:', id)
        
        return {
          success: true,
          data: transformOrderToCRUD(updatedOrder.order)
        }
      } catch (error) {
        console.error('‚ùå OrderServiceAdapter.update error:', error)
        return {
          success: false,
          error: error instanceof Error ? error.message : 'Failed to update order'
        }
      }
    },

    async delete(organizationId: string, id: string) {
      console.log('üîç OrderServiceAdapter.delete called with:', { organizationId, id })
      
      try {
        const result = await UniversalTransactionService.deleteOrder(id)
        
        if (!result.success) {
          throw new Error(result.error || 'Failed to delete order')
        }
        
        console.log('‚úÖ OrderServiceAdapter.delete success:', id)
        
        return {
          success: true,
          data: { id }
        }
      } catch (error) {
        console.error('‚ùå OrderServiceAdapter.delete error:', error)
        return {
          success: false,
          error: error instanceof Error ? error.message : 'Failed to delete order'
        }
      }
    },

    async get(organizationId: string, id: string) {
      console.log('üîç OrderServiceAdapter.get called with:', { organizationId, id })
      
      try {
        const result = await UniversalTransactionService.getOrder(id)
        
        if (!result.success) {
          throw new Error(result.error || 'Failed to fetch order')
        }
        
        console.log('‚úÖ OrderServiceAdapter.get success:', id)
        
        return {
          success: true,
          data: transformOrderToCRUD(result.order)
        }
      } catch (error) {
        console.error('‚ùå OrderServiceAdapter.get error:', error)
        return {
          success: false,
          error: error instanceof Error ? error.message : 'Failed to fetch order'
        }
      }
    }
  }
}

// üîÑ Data Transformation Functions
function transformOrderToCRUD(order: any): OrderEntity {
  if (!order) return null
  
  return {
    id: order.id,
    organizationId: order.organizationId,
    
    // Universal Transaction Fields
    transaction_number: order.transaction_number,
    transaction_type: 'SALES_ORDER',
    transaction_date: order.transaction_date,
    transaction_status: order.transaction_status,
    total_amount: order.total_amount,
    currency: order.currency || 'USD',
    
    // Order-Specific Fields
    customer_name: order.metadata?.customer_name || order.customerName,
    customer_phone: order.metadata?.customer_phone || order.customerPhone,
    order_type: order.metadata?.order_type || order.orderType || 'dine_in',
    table_number: order.metadata?.table_number || order.tableNumber,
    
    // Financial Details
    subtotal: order.metadata?.subtotal || order.subtotal,
    tax_amount: order.metadata?.tax_amount || order.taxAmount,
    tip_amount: order.metadata?.tip_amount || order.tipAmount,
    payment_method: order.metadata?.payment_method || order.paymentMethod,
    payment_status: order.metadata?.payment_status || order.paymentStatus,
    
    // Timing
    estimated_completion: order.metadata?.estimated_completion || order.estimatedCompletion,
    actual_completion: order.metadata?.actual_completion || order.actualCompletion,
    
    // Instructions and Notes
    special_instructions: order.metadata?.special_instructions || order.specialInstructions,
    delivery_address: order.metadata?.delivery_address || order.deliveryAddress,
    delivery_fee: order.metadata?.delivery_fee || order.deliveryFee,
    assigned_staff: order.metadata?.assigned_staff || order.assignedStaff,
    internal_notes: order.metadata?.internal_notes || order.internalNotes,
    
    // System Fields
    created_at: order.created_at,
    updated_at: order.updated_at,
    
    // Order Items
    items: order.items || []
  }
}

// üìä Order Statistics Service
export const createOrderStatisticsService = () => {
  return {
    async getOrderStatistics(organizationId: string, dateRange?: { start: string; end: string }): Promise<OrderStatistics> {
      console.log('üìä Getting order statistics for:', { organizationId, dateRange })
      
      try {
        const result = await UniversalTransactionService.getOrderStatistics(organizationId, dateRange)
        
        return {
          total_orders: result.totalOrders || 0,
          pending_orders: result.pendingOrders || 0,
          active_orders: result.activeOrders || 0,
          completed_orders: result.completedOrders || 0,
          cancelled_orders: result.cancelledOrders || 0,
          total_revenue: result.totalRevenue || 0,
          average_order_value: result.averageOrderValue || 0,
          peak_hours: result.peakHours || 'N/A'
        }
      } catch (error) {
        console.error('‚ùå Failed to get order statistics:', error)
        return {
          total_orders: 0,
          pending_orders: 0,
          active_orders: 0,
          completed_orders: 0,
          cancelled_orders: 0,
          total_revenue: 0,
          average_order_value: 0,
          peak_hours: 'N/A'
        }
      }
    }
  }
}

// üîÑ Order Workflow Management
export const createOrderWorkflowService = () => {
  return {
    async confirmOrder(orderId: string): Promise<{ success: boolean; error?: string }> {
      return await UniversalTransactionService.updateOrderStatus(orderId, 'CONFIRMED')
    },
    
    async startPreparation(orderId: string): Promise<{ success: boolean; error?: string }> {
      return await UniversalTransactionService.updateOrderStatus(orderId, 'PREPARING')
    },
    
    async markReady(orderId: string): Promise<{ success: boolean; error?: string }> {
      return await UniversalTransactionService.updateOrderStatus(orderId, 'READY')
    },
    
    async completeOrder(orderId: string): Promise<{ success: boolean; error?: string }> {
      const result = await UniversalTransactionService.updateOrderStatus(orderId, 'COMPLETED')
      
      if (result.success) {
        // Update actual completion time
        await UniversalTransactionService.updateOrder(orderId, {
          actualCompletion: new Date().toISOString()
        })
      }
      
      return result
    },
    
    async cancelOrder(orderId: string, reason?: string): Promise<{ success: boolean; error?: string }> {
      const result = await UniversalTransactionService.updateOrderStatus(orderId, 'CANCELLED')
      
      if (result.success && reason) {
        await UniversalTransactionService.updateOrder(orderId, {
          internalNotes: reason
        })
      }
      
      return result
    }
  }
}

// üîÑ Real-time Order Updates
export const createOrderRealtimeService = () => {
  return {
    subscribeToOrderUpdates(organizationId: string, callback: (order: OrderEntity) => void) {
      console.log('üîî Subscribing to order updates for:', organizationId)
      
      return UniversalTransactionService.subscribeToOrderChanges(organizationId, (payload) => {
        const transformedOrder = transformOrderToCRUD(payload.new)
        callback(transformedOrder)
      })
    },
    
    unsubscribeFromOrderUpdates(subscription: any) {
      console.log('üîï Unsubscribing from order updates')
      subscription?.unsubscribe()
    }
  }
}

// üéØ Export all services
export default {
  createOrderServiceAdapter,
  createOrderStatisticsService,
  createOrderWorkflowService,
  createOrderRealtimeService
}